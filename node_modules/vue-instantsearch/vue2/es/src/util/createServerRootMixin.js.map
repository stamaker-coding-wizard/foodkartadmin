{"version":3,"file":"createServerRootMixin.js","sources":["../../../../src/util/createServerRootMixin.js"],"sourcesContent":["import instantsearch from 'instantsearch.js/es';\nimport {\n  waitForResults,\n  getInitialResults,\n} from 'instantsearch.js/es/lib/server';\n\nimport { isVue3, isVue2, Vue2, createSSRApp } from './vue-compat';\nimport { warn } from './warn';\n\nfunction defaultCloneComponent(componentInstance, { mixins = [] } = {}) {\n  const options = {\n    serverPrefetch: undefined,\n    fetch: undefined,\n    _base: undefined,\n    name: 'ais-ssr-root-component',\n  };\n\n  let app;\n\n  if (isVue3) {\n    const appOptions = Object.assign({}, componentInstance.$options, options);\n    appOptions.mixins = [...mixins, ...(appOptions.mixins || [])];\n    app = createSSRApp(appOptions);\n    if (componentInstance.$router) {\n      app.use(componentInstance.$router);\n    }\n    if (componentInstance.$store) {\n      app.use(componentInstance.$store);\n    }\n    if (componentInstance.$i18n) {\n      app.use(componentInstance.$i18n);\n    }\n  } else {\n    // copy over global Vue APIs\n    options.router = componentInstance.$router;\n    options.store = componentInstance.$store;\n    options.i18n = componentInstance.$i18n;\n\n    const Extended = componentInstance.$vnode\n      ? componentInstance.$vnode.componentOptions.Ctor.extend(options)\n      : Vue2.component(\n          options.name,\n          Object.assign({}, componentInstance.$options, options)\n        );\n\n    app = new Extended({\n      propsData: componentInstance.$options.propsData,\n      mixins: [...mixins],\n    });\n  }\n\n  // https://stackoverflow.com/a/48195006/3185307\n  app.$slots = componentInstance.$slots;\n  app.$root = componentInstance.$root;\n  if (isVue2) {\n    app.$options.serverPrefetch = [];\n  }\n\n  return app;\n}\n\nfunction augmentInstantSearch(instantSearchOptions, cloneComponent) {\n  const search = instantsearch(instantSearchOptions);\n\n  let initialResults;\n\n  /**\n   * main API for SSR, called in serverPrefetch of a root component which contains instantsearch\n   * @param {Object} props the object including `component` and `renderToString`\n   * @param {Object} props.component the calling component's `this`\n   * @param {Function} props.renderToString the function to render componentInstance to string\n   * @returns {Promise} result of the search, to save for .hydrate\n   */\n  search.findResultsState = function ({ component, renderToString }) {\n    if (!renderToString) {\n      throw new Error(\n        'findResultsState requires `renderToString: (component) => Promise<string>` in the first argument.'\n      );\n    }\n\n    let app;\n    let instance;\n\n    return Promise.resolve()\n      .then(() => {\n        app = cloneComponent(component, {\n          mixins: [\n            {\n              beforeCreate() {\n                const descriptor = Object.getOwnPropertyDescriptor(\n                  component,\n                  '$nuxt'\n                );\n\n                const isWritable = descriptor\n                  ? descriptor.writable || descriptor.set\n                  : false;\n\n                if (component.$nuxt && isWritable) {\n                  // In case of Nuxt (3), we ensure the context is shared between\n                  // the real and cloned component\n                  this.$nuxt = component.$nuxt;\n                }\n              },\n              created() {\n                instance = this.instantsearch;\n\n                instance.start();\n                // although we use start for initializing the main index,\n                // we don't want to send search requests yet\n                instance.started = false;\n              },\n            },\n          ],\n        });\n      })\n      .then(() => renderToString(app))\n      .then(() => waitForResults(instance))\n      .then(() => {\n        initialResults = getInitialResults(instance.mainIndex);\n        search.hydrate(initialResults);\n        return search.getState();\n      });\n  };\n\n  /**\n   * @returns {Promise} result state to serialize and enter into .hydrate\n   */\n  search.getState = function () {\n    if (!initialResults) {\n      throw new Error('You need to wait for findResultsState to finish');\n    }\n    return initialResults;\n  };\n\n  /**\n   * make sure correct data is available in each widget's state.\n   * called in widget mixin with (this.widget, this)\n   *\n   * @param {object} widget The widget instance\n   * @param {object} parent The local parent index\n   * @returns {void}\n   */\n  search.__forceRender = function (widget, parent) {\n    const results = parent.getResults();\n\n    // this happens when a different InstantSearch gets rendered initially,\n    // after the hydrate finished. There's thus no initial results available.\n    if (results === null) {\n      return;\n    }\n\n    const state = results._state;\n\n    const localHelper = parent.getHelper();\n    // helper gets created in init, but that means it doesn't get the injected\n    // parameters, because those are from the lastResults\n    localHelper.state = state;\n\n    widget.render({\n      helper: localHelper,\n      results,\n      scopedResults: parent.getScopedResults(),\n      parent,\n      state,\n      templatesConfig: {},\n      createURL: parent.createURL,\n      instantSearchInstance: search,\n      searchMetadata: {\n        isSearchStalled: false,\n      },\n    });\n  };\n\n  /**\n   * Called both in server\n   * @param {object} results a map of indexId: SearchResults\n   * @returns {void}\n   */\n  search.hydrate = function (results) {\n    if (!results) {\n      warn(\n        'The result of `findResultsState()` needs to be passed to `hydrate()`.'\n      );\n      return;\n    }\n\n    search._initialResults = results;\n\n    search.start();\n    search.started = false;\n  };\n  return search;\n}\n\nexport function createServerRootMixin(instantSearchOptions = {}) {\n  const { $cloneComponent = defaultCloneComponent } = instantSearchOptions;\n\n  const search = augmentInstantSearch(instantSearchOptions, $cloneComponent);\n\n  // put this in the user's root Vue instance\n  // we can then reuse that InstantSearch instance seamlessly from `ais-instant-search-ssr`\n  const rootMixin = {\n    provide() {\n      return {\n        $_ais_ssrInstantSearchInstance: this.instantsearch,\n      };\n    },\n    data() {\n      return {\n        // this is in data, so that the real & cloned render do not share\n        // the same instantsearch instance.\n        instantsearch: search,\n      };\n    },\n  };\n\n  return rootMixin;\n}\n"],"names":["defaultCloneComponent","componentInstance","const","app","options","serverPrefetch","undefined","fetch","_base","name","router","$router","store","$store","i18n","$i18n","$vnode","componentOptions","Ctor","extend","Vue2","component","Object","assign","$options","propsData","mixins","$slots","$root","createServerRootMixin","instantSearchOptions","search","cloneComponent","initialResults","instantsearch","findResultsState","instance","renderToString","Error","Promise","resolve","then","beforeCreate","descriptor","getOwnPropertyDescriptor","isWritable","writable","set","$nuxt","this","created","start","started","waitForResults","getInitialResults","mainIndex","hydrate","getState","__forceRender","widget","parent","results","getResults","state","_state","localHelper","getHelper","render","helper","scopedResults","getScopedResults","templatesConfig","createURL","instantSearchInstance","searchMetadata","isSearchStalled","_initialResults","warn","augmentInstantSearch","$cloneComponent","provide","$_ais_ssrInstantSearchInstance","data"],"mappings":"yNASA,SAASA,EAAsBC,oBAAqC,kCAAP,IAC3DC,IAOIC,EAPEC,EAAU,CACdC,oBAAgBC,EAChBC,WAAOD,EACPE,WAAOF,EACPG,KAAM,0BA4CR,OAxBEL,EAAQM,OAAST,EAAkBU,QACnCP,EAAQQ,MAAQX,EAAkBY,OAClCT,EAAQU,KAAOb,EAAkBc,OASjCZ,EAAM,IAPWF,EAAkBe,OAC/Bf,EAAkBe,OAAOC,iBAAiBC,KAAKC,OAAOf,GACtDgB,EAAKC,UACHjB,EAAQK,KACRa,OAAOC,OAAO,GAAItB,EAAkBuB,SAAUpB,KAGjC,CACjBqB,UAAWxB,EAAkBuB,SAASC,UACtCC,OAAQ,UAAIA,MAKZC,OAAS1B,EAAkB0B,OAC/BxB,EAAIyB,MAAQ3B,EAAkB2B,MAE5BzB,EAAIqB,SAASnB,eAAiB,GAGzBF,EAyIF,SAAS0B,EAAsBC,kBAAuB,2CACjC9B,GAE1BE,IAAM6B,EAzIR,SAA8BD,EAAsBE,GAClD9B,IAEI+B,EAFEF,EAASG,EAAcJ,GAkI7B,OAvHAC,EAAOI,iBAAmB,gBAOpBhC,EACAiC,mCAPJ,IAAKC,EACH,MAAM,IAAIC,MACR,qGAOJ,OAAOC,QAAQC,UACZC,gBACCtC,EAAM6B,EAAeX,EAAW,CAC9BK,OAAQ,CACN,CACEgB,wBACExC,IAAMyC,EAAarB,OAAOsB,yBACxBvB,EACA,SAGIwB,IAAaF,IACfA,EAAWG,UAAYH,EAAWI,KAGlC1B,EAAU2B,OAASH,IAGrBI,KAAKD,MAAQ3B,EAAU2B,QAG3BE,oBACEd,EAAWa,KAAKf,eAEPiB,QAGTf,EAASgB,SAAU,SAM5BX,uBAAWJ,EAAelC,KAC1BsC,uBAAWY,EAAejB,KAC1BK,gBAGC,OAFAR,EAAiBqB,EAAkBlB,EAASmB,WAC5CxB,EAAOyB,QAAQvB,GACRF,EAAO0B,cAOpB1B,EAAO0B,SAAW,WAChB,IAAKxB,EACH,MAAM,IAAIK,MAAM,mDAElB,OAAOL,GAWTF,EAAO2B,cAAgB,SAAUC,EAAQC,GACvC1D,IAAM2D,EAAUD,EAAOE,aAIvB,GAAgB,OAAZD,EAAJ,CAIA3D,IAAM6D,EAAQF,EAAQG,OAEhBC,EAAcL,EAAOM,YAG3BD,EAAYF,MAAQA,EAEpBJ,EAAOQ,OAAO,CACZC,OAAQH,UACRJ,EACAQ,cAAeT,EAAOU,0BACtBV,QACAG,EACAQ,gBAAiB,GACjBC,UAAWZ,EAAOY,UAClBC,sBAAuB1C,EACvB2C,eAAgB,CACdC,iBAAiB,OAUvB5C,EAAOyB,QAAU,SAAUK,GACpBA,GAOL9B,EAAO6C,gBAAkBf,EAEzB9B,EAAOoB,QACPpB,EAAOqB,SAAU,GATfyB,EACE,0EAUC9C,EAMQ+C,CAAqBhD,EAAsBiD,GAmB1D,MAfkB,CAChBC,mBACE,MAAO,CACLC,+BAAgChC,KAAKf,gBAGzCgD,gBACE,MAAO,CAGLhD,cAAeH"}