{"version":3,"file":"createServerRootMixin.js","sources":["../../../../src/util/createServerRootMixin.js"],"sourcesContent":["import instantsearch from 'instantsearch.js/es';\nimport {\n  waitForResults,\n  getInitialResults,\n} from 'instantsearch.js/es/lib/server';\n\nimport { isVue3, isVue2, Vue2, createSSRApp } from './vue-compat';\nimport { warn } from './warn';\n\nfunction defaultCloneComponent(componentInstance, { mixins = [] } = {}) {\n  const options = {\n    serverPrefetch: undefined,\n    fetch: undefined,\n    _base: undefined,\n    name: 'ais-ssr-root-component',\n  };\n\n  let app;\n\n  if (isVue3) {\n    const appOptions = Object.assign({}, componentInstance.$options, options);\n    appOptions.mixins = [...mixins, ...(appOptions.mixins || [])];\n    app = createSSRApp(appOptions);\n    if (componentInstance.$router) {\n      app.use(componentInstance.$router);\n    }\n    if (componentInstance.$store) {\n      app.use(componentInstance.$store);\n    }\n    if (componentInstance.$i18n) {\n      app.use(componentInstance.$i18n);\n    }\n  } else {\n    // copy over global Vue APIs\n    options.router = componentInstance.$router;\n    options.store = componentInstance.$store;\n    options.i18n = componentInstance.$i18n;\n\n    const Extended = componentInstance.$vnode\n      ? componentInstance.$vnode.componentOptions.Ctor.extend(options)\n      : Vue2.component(\n          options.name,\n          Object.assign({}, componentInstance.$options, options)\n        );\n\n    app = new Extended({\n      propsData: componentInstance.$options.propsData,\n      mixins: [...mixins],\n    });\n  }\n\n  // https://stackoverflow.com/a/48195006/3185307\n  app.$slots = componentInstance.$slots;\n  app.$root = componentInstance.$root;\n  if (isVue2) {\n    app.$options.serverPrefetch = [];\n  }\n\n  return app;\n}\n\nfunction augmentInstantSearch(instantSearchOptions, cloneComponent) {\n  const search = instantsearch(instantSearchOptions);\n\n  let initialResults;\n\n  /**\n   * main API for SSR, called in serverPrefetch of a root component which contains instantsearch\n   * @param {Object} props the object including `component` and `renderToString`\n   * @param {Object} props.component the calling component's `this`\n   * @param {Function} props.renderToString the function to render componentInstance to string\n   * @returns {Promise} result of the search, to save for .hydrate\n   */\n  search.findResultsState = function ({ component, renderToString }) {\n    if (!renderToString) {\n      throw new Error(\n        'findResultsState requires `renderToString: (component) => Promise<string>` in the first argument.'\n      );\n    }\n\n    let app;\n    let instance;\n\n    return Promise.resolve()\n      .then(() => {\n        app = cloneComponent(component, {\n          mixins: [\n            {\n              beforeCreate() {\n                const descriptor = Object.getOwnPropertyDescriptor(\n                  component,\n                  '$nuxt'\n                );\n\n                const isWritable = descriptor\n                  ? descriptor.writable || descriptor.set\n                  : false;\n\n                if (component.$nuxt && isWritable) {\n                  // In case of Nuxt (3), we ensure the context is shared between\n                  // the real and cloned component\n                  this.$nuxt = component.$nuxt;\n                }\n              },\n              created() {\n                instance = this.instantsearch;\n\n                instance.start();\n                // although we use start for initializing the main index,\n                // we don't want to send search requests yet\n                instance.started = false;\n              },\n            },\n          ],\n        });\n      })\n      .then(() => renderToString(app))\n      .then(() => waitForResults(instance))\n      .then(() => {\n        initialResults = getInitialResults(instance.mainIndex);\n        search.hydrate(initialResults);\n        return search.getState();\n      });\n  };\n\n  /**\n   * @returns {Promise} result state to serialize and enter into .hydrate\n   */\n  search.getState = function () {\n    if (!initialResults) {\n      throw new Error('You need to wait for findResultsState to finish');\n    }\n    return initialResults;\n  };\n\n  /**\n   * make sure correct data is available in each widget's state.\n   * called in widget mixin with (this.widget, this)\n   *\n   * @param {object} widget The widget instance\n   * @param {object} parent The local parent index\n   * @returns {void}\n   */\n  search.__forceRender = function (widget, parent) {\n    const results = parent.getResults();\n\n    // this happens when a different InstantSearch gets rendered initially,\n    // after the hydrate finished. There's thus no initial results available.\n    if (results === null) {\n      return;\n    }\n\n    const state = results._state;\n\n    const localHelper = parent.getHelper();\n    // helper gets created in init, but that means it doesn't get the injected\n    // parameters, because those are from the lastResults\n    localHelper.state = state;\n\n    widget.render({\n      helper: localHelper,\n      results,\n      scopedResults: parent.getScopedResults(),\n      parent,\n      state,\n      templatesConfig: {},\n      createURL: parent.createURL,\n      instantSearchInstance: search,\n      searchMetadata: {\n        isSearchStalled: false,\n      },\n    });\n  };\n\n  /**\n   * Called both in server\n   * @param {object} results a map of indexId: SearchResults\n   * @returns {void}\n   */\n  search.hydrate = function (results) {\n    if (!results) {\n      warn(\n        'The result of `findResultsState()` needs to be passed to `hydrate()`.'\n      );\n      return;\n    }\n\n    search._initialResults = results;\n\n    search.start();\n    search.started = false;\n  };\n  return search;\n}\n\nexport function createServerRootMixin(instantSearchOptions = {}) {\n  const { $cloneComponent = defaultCloneComponent } = instantSearchOptions;\n\n  const search = augmentInstantSearch(instantSearchOptions, $cloneComponent);\n\n  // put this in the user's root Vue instance\n  // we can then reuse that InstantSearch instance seamlessly from `ais-instant-search-ssr`\n  const rootMixin = {\n    provide() {\n      return {\n        $_ais_ssrInstantSearchInstance: this.instantsearch,\n      };\n    },\n    data() {\n      return {\n        // this is in data, so that the real & cloned render do not share\n        // the same instantsearch instance.\n        instantsearch: search,\n      };\n    },\n  };\n\n  return rootMixin;\n}\n"],"names":["defaultCloneComponent","componentInstance","const","app","options","serverPrefetch","undefined","fetch","_base","name","appOptions","Object","assign","$options","mixins","createSSRApp","$router","use","$store","$i18n","$slots","$root","createServerRootMixin","instantSearchOptions","search","cloneComponent","initialResults","instantsearch","findResultsState","instance","renderToString","Error","Promise","resolve","then","component","beforeCreate","descriptor","getOwnPropertyDescriptor","isWritable","writable","set","$nuxt","this","created","start","started","waitForResults","getInitialResults","mainIndex","hydrate","getState","__forceRender","widget","parent","results","getResults","state","_state","localHelper","getHelper","render","helper","scopedResults","getScopedResults","templatesConfig","createURL","instantSearchInstance","searchMetadata","isSearchStalled","_initialResults","warn","augmentInstantSearch","$cloneComponent","provide","$_ais_ssrInstantSearchInstance","data"],"mappings":"6OASA,SAASA,EAAsBC,oBAAqC,kCAAP,IAC3DC,IAOIC,EAPEC,EAAU,CACdC,oBAAgBC,EAChBC,WAAOD,EACPE,WAAOF,EACPG,KAAM,0BAMAC,EAAaC,OAAOC,OAAO,GAAIX,EAAkBY,SAAUT,GAsCnE,OArCEM,EAAWI,OAAaA,SAAYJ,EAAWI,QAAU,IACzDX,EAAMY,EAAaL,GACfT,EAAkBe,SACpBb,EAAIc,IAAIhB,EAAkBe,SAExBf,EAAkBiB,QACpBf,EAAIc,IAAIhB,EAAkBiB,QAExBjB,EAAkBkB,OACpBhB,EAAIc,IAAIhB,EAAkBkB,OAsB9BhB,EAAIiB,OAASnB,EAAkBmB,OAC/BjB,EAAIkB,MAAQpB,EAAkBoB,MAKvBlB,EAyIF,SAASmB,EAAsBC,kBAAuB,2CACjCvB,GAE1BE,IAAMsB,EAzIR,SAA8BD,EAAsBE,GAClDvB,IAEIwB,EAFEF,EAASG,EAAcJ,GAkI7B,OAvHAC,EAAOI,iBAAmB,gBAOpBzB,EACA0B,mCAPJ,IAAKC,EACH,MAAM,IAAIC,MACR,qGAOJ,OAAOC,QAAQC,UACZC,gBACC/B,EAAMsB,EAAeU,EAAW,CAC9BrB,OAAQ,CACN,CACEsB,wBACElC,IAAMmC,EAAa1B,OAAO2B,yBACxBH,EACA,SAGII,IAAaF,IACfA,EAAWG,UAAYH,EAAWI,KAGlCN,EAAUO,OAASH,IAGrBI,KAAKD,MAAQP,EAAUO,QAG3BE,oBACEf,EAAWc,KAAKhB,eAEPkB,QAGThB,EAASiB,SAAU,SAM5BZ,uBAAWJ,EAAe3B,KAC1B+B,uBAAWa,EAAelB,KAC1BK,gBAGC,OAFAR,EAAiBsB,EAAkBnB,EAASoB,WAC5CzB,EAAO0B,QAAQxB,GACRF,EAAO2B,cAOpB3B,EAAO2B,SAAW,WAChB,IAAKzB,EACH,MAAM,IAAIK,MAAM,mDAElB,OAAOL,GAWTF,EAAO4B,cAAgB,SAAUC,EAAQC,GACvCpD,IAAMqD,EAAUD,EAAOE,aAIvB,GAAgB,OAAZD,EAAJ,CAIArD,IAAMuD,EAAQF,EAAQG,OAEhBC,EAAcL,EAAOM,YAG3BD,EAAYF,MAAQA,EAEpBJ,EAAOQ,OAAO,CACZC,OAAQH,UACRJ,EACAQ,cAAeT,EAAOU,0BACtBV,QACAG,EACAQ,gBAAiB,GACjBC,UAAWZ,EAAOY,UAClBC,sBAAuB3C,EACvB4C,eAAgB,CACdC,iBAAiB,OAUvB7C,EAAO0B,QAAU,SAAUK,GACpBA,GAOL/B,EAAO8C,gBAAkBf,EAEzB/B,EAAOqB,QACPrB,EAAOsB,SAAU,GATfyB,EACE,0EAUC/C,EAMQgD,CAAqBjD,EAAsBkD,GAmB1D,MAfkB,CAChBC,mBACE,MAAO,CACLC,+BAAgChC,KAAKhB,gBAGzCiD,gBACE,MAAO,CAGLjD,cAAeH"}